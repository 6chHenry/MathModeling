<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/predict.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/predict.py" />
              <option name="updatedContent" value="import pandas as pd&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;import seaborn as sns&#10;from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor&#10;from sklearn.linear_model import Ridge&#10;from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV&#10;from sklearn.preprocessing import OneHotEncoder, StandardScaler, LabelEncoder&#10;from sklearn.compose import ColumnTransformer&#10;from sklearn.pipeline import Pipeline&#10;from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error&#10;import warnings&#10;warnings.filterwarnings('ignore')&#10;&#10;plt.rcParams['font.sans-serif'] = ['SimHei']&#10;plt.rcParams['axes.unicode_minus'] = False&#10;&#10;class MovieRatingPredictor:&#10;    def __init__(self):&#10;        self.model = None&#10;        self.preprocessor = None&#10;        self.feature_names = None&#10;        self.training_history = {}&#10;        &#10;    def load_and_preprocess_data(self, train_path, test_path):&#10;        &quot;&quot;&quot;加载和预处理数据&quot;&quot;&quot;&#10;        print(&quot;正在加载数据...&quot;)&#10;        &#10;        # 加载训练数据&#10;        try:&#10;            self.train_df = pd.read_csv(train_path)&#10;            print(f&quot;训练数据形状: {self.train_df.shape}&quot;)&#10;        except:&#10;            print(&quot;无法读取训练数据，尝试读取movie_features.npy&quot;)&#10;            # 如果CSV太大，尝试加载预处理的特征&#10;            features = np.load('movie_features.npy')&#10;            with open('feature_names.txt', 'r') as f:&#10;                feature_names = f.read().strip().split('\n')&#10;            self.train_df = pd.DataFrame(features, columns=feature_names)&#10;        &#10;        # 加载测试数据&#10;        self.test_df = pd.read_csv(test_path)&#10;        print(f&quot;测试数据形状: {self.test_df.shape}&quot;)&#10;        &#10;        # 特征工程&#10;        self.train_df = self._feature_engineering(self.train_df)&#10;        self.test_df = self._feature_engineering(self.test_df)&#10;        &#10;        return self.train_df, self.test_df&#10;    &#10;    def _feature_engineering(self, df):&#10;        &quot;&quot;&quot;特征工程&quot;&quot;&quot;&#10;        df = df.copy()&#10;        &#10;        # 处理类型特征&#10;        if 'genres' in df.columns:&#10;            df['main_genre'] = df['genres'].str.split(',').str[0]&#10;            df['genre_count'] = df['genres'].str.count(',') + 1&#10;        &#10;        # 处理演员特征&#10;        if 'cast' in df.columns:&#10;            df['cast_count'] = df['cast'].str.count(',') + 1&#10;            df['cast_count'] = df['cast_count'].fillna(0)&#10;        &#10;        # 处理导演特征&#10;        if 'director' in df.columns:&#10;            df['has_director'] = df['director'].notna().astype(int)&#10;        &#10;        # 处理编剧特征&#10;        if 'writers' in df.columns:&#10;            df['writers_count'] = df['writers'].str.count(',') + 1&#10;            df['writers_count'] = df['writers_count'].fillna(0)&#10;        &#10;        # 处理制片公司特征&#10;        if 'production_companies' in df.columns:&#10;            df['production_count'] = df['production_companies'].str.count(',') + 1&#10;            df['production_count'] = df['production_count'].fillna(0)&#10;        &#10;        # 处理语言特征&#10;        if 'original_language' in df.columns:&#10;            df['lang'] = df['original_language']&#10;        &#10;        # 处理时长特征&#10;        if 'runtime' in df.columns:&#10;            df['runtime'] = df['runtime'].fillna(df['runtime'].median())&#10;            df['runtime_category'] = pd.cut(df['runtime'], &#10;                                          bins=[0, 90, 120, 150, float('inf')],&#10;                                          labels=['短片', '标准', '长片', '超长'])&#10;        &#10;        return df&#10;    &#10;    def prepare_features(self, df, is_train=True):&#10;        &quot;&quot;&quot;准备特征&quot;&quot;&quot;&#10;        feature_columns = []&#10;        &#10;        # 数值特征&#10;        numeric_features = []&#10;        if 'runtime' in df.columns:&#10;            numeric_features.append('runtime')&#10;        if 'cast_count' in df.columns:&#10;            numeric_features.append('cast_count')&#10;        if 'writers_count' in df.columns:&#10;            numeric_features.append('writers_count')&#10;        if 'production_count' in df.columns:&#10;            numeric_features.append('production_count')&#10;        if 'genre_count' in df.columns:&#10;            numeric_features.append('genre_count')&#10;        if 'has_director' in df.columns:&#10;            numeric_features.append('has_director')&#10;            &#10;        # 类别特征&#10;        categorical_features = []&#10;        if 'main_genre' in df.columns:&#10;            categorical_features.append('main_genre')&#10;        if 'lang' in df.columns:&#10;            categorical_features.append('lang')&#10;        if 'runtime_category' in df.columns:&#10;            categorical_features.append('runtime_category')&#10;        &#10;        # 创建特征矩阵&#10;        features_df = pd.DataFrame()&#10;        &#10;        # 添加数值特征&#10;        for col in numeric_features:&#10;            if col in df.columns:&#10;                features_df[col] = df[col].fillna(0)&#10;        &#10;        # 添加类别特征&#10;        for col in categorical_features:&#10;            if col in df.columns:&#10;                features_df[col] = df[col].fillna('Unknown')&#10;        &#10;        return features_df, numeric_features, categorical_features&#10;    &#10;    def build_model(self):&#10;        &quot;&quot;&quot;构建模型&quot;&quot;&quot;&#10;        # 集成多个模型&#10;        models = {&#10;            'random_forest': RandomForestRegressor(&#10;                n_estimators=200,&#10;                max_depth=15,&#10;                min_samples_split=5,&#10;                min_samples_leaf=2,&#10;                random_state=42,&#10;                n_jobs=-1&#10;            ),&#10;            'gradient_boosting': GradientBoostingRegressor(&#10;                n_estimators=200,&#10;                learning_rate=0.1,&#10;                max_depth=6,&#10;                random_state=42&#10;            ),&#10;            'ridge': Ridge(alpha=1.0)&#10;        }&#10;        &#10;        return models&#10;    &#10;    def train_and_evaluate(self, X_train, y_train):&#10;        &quot;&quot;&quot;训练和评估模型&quot;&quot;&quot;&#10;        print(&quot;开始训练模型...&quot;)&#10;        &#10;        # 准备特征&#10;        X_features, numeric_features, categorical_features = self.prepare_features(X_train)&#10;        &#10;        # 创建预处理器&#10;        preprocessor = ColumnTransformer(&#10;            transformers=[&#10;                ('num', StandardScaler(), numeric_features),&#10;                ('cat', OneHotEncoder(handle_unknown='ignore', sparse_output=False), categorical_features)&#10;            ],&#10;            remainder='passthrough'&#10;        )&#10;        &#10;        # 构建模型&#10;        models = self.build_model()&#10;        &#10;        # 训练和验证每个模型&#10;        model_scores = {}&#10;        trained_models = {}&#10;        &#10;        # 分割训练和验证集&#10;        X_train_split, X_val_split, y_train_split, y_val_split = train_test_split(&#10;            X_features, y_train, test_size=0.2, random_state=42&#10;        )&#10;        &#10;        for name, model in models.items():&#10;            print(f&quot;训练 {name}...&quot;)&#10;            &#10;            # 创建管道&#10;            pipeline = Pipeline([&#10;                ('preprocessor', preprocessor),&#10;                ('model', model)&#10;            ])&#10;            &#10;            # 训练模型&#10;            pipeline.fit(X_train_split, y_train_split)&#10;            &#10;            # 预测&#10;            y_pred = pipeline.predict(X_val_split)&#10;            &#10;            # 计算评分&#10;            mse = mean_squared_error(y_val_split, y_pred)&#10;            rmse = np.sqrt(mse)&#10;            mae = mean_absolute_error(y_val_split, y_pred)&#10;            r2 = r2_score(y_val_split, y_pred)&#10;            &#10;            model_scores[name] = {&#10;                'MSE': mse,&#10;                'RMSE': rmse,&#10;                'MAE': mae,&#10;                'R2': r2&#10;            }&#10;            &#10;            trained_models[name] = pipeline&#10;            &#10;            print(f&quot;{name} - RMSE: {rmse:.4f}, R2: {r2:.4f}&quot;)&#10;        &#10;        # 选择最佳模型&#10;        best_model_name = min(model_scores.keys(), key=lambda x: model_scores[x]['RMSE'])&#10;        self.model = trained_models[best_model_name]&#10;        self.preprocessor = self.model.named_steps['preprocessor']&#10;        &#10;        print(f&quot;最佳模型: {best_model_name}&quot;)&#10;        &#10;        return model_scores, trained_models&#10;    &#10;    def visualize_results(self, model_scores, X_val, y_val):&#10;        &quot;&quot;&quot;可视化结果&quot;&quot;&quot;&#10;        print(&quot;生成可视化结果...&quot;)&#10;        &#10;        # 1. 模型性能比较&#10;        plt.figure(figsize=(15, 10))&#10;        &#10;        # RMSE比较&#10;        plt.subplot(2, 3, 1)&#10;        models = list(model_scores.keys())&#10;        rmse_values = [model_scores[m]['RMSE'] for m in models]&#10;        plt.bar(models, rmse_values, color='skyblue')&#10;        plt.title('模型RMSE比较')&#10;        plt.ylabel('RMSE')&#10;        plt.xticks(rotation=45)&#10;        &#10;        # R2比较&#10;        plt.subplot(2, 3, 2)&#10;        r2_values = [model_scores[m]['R2'] for m in models]&#10;        plt.bar(models, r2_values, color='lightgreen')&#10;        plt.title('模型R²比较')&#10;        plt.ylabel('R²')&#10;        plt.xticks(rotation=45)&#10;        &#10;        # 预测vs实际&#10;        plt.subplot(2, 3, 3)&#10;        X_features, _, _ = self.prepare_features(X_val)&#10;        y_pred = self.model.predict(X_features)&#10;        plt.scatter(y_val, y_pred, alpha=0.6)&#10;        plt.plot([y_val.min(), y_val.max()], [y_val.min(), y_val.max()], 'r--', lw=2)&#10;        plt.xlabel('实际评分')&#10;        plt.ylabel('预测评分')&#10;        plt.title('预测值 vs 实际值')&#10;        &#10;        # 残差图&#10;        plt.subplot(2, 3, 4)&#10;        residuals = y_val - y_pred&#10;        plt.scatter(y_pred, residuals, alpha=0.6)&#10;        plt.axhline(y=0, color='r', linestyle='--')&#10;        plt.xlabel('预测评分')&#10;        plt.ylabel('残差')&#10;        plt.title('残差图')&#10;        &#10;        # 损失历史（如果有的话）&#10;        plt.subplot(2, 3, 5)&#10;        if hasattr(self.model.named_steps['model'], 'train_score_'):&#10;            train_scores = self.model.named_steps['model'].train_score_&#10;            plt.plot(train_scores, label='训练损失')&#10;            plt.xlabel('迭代次数')&#10;            plt.ylabel('损失')&#10;            plt.title('训练损失曲线')&#10;            plt.legend()&#10;        else:&#10;            plt.text(0.5, 0.5, '该模型无训练历史', ha='center', va='center', transform=plt.gca().transAxes)&#10;        &#10;        # 特征重要性（如果是树模型）&#10;        plt.subplot(2, 3, 6)&#10;        if hasattr(self.model.named_steps['model'], 'feature_importances_'):&#10;            importances = self.model.named_steps['model'].feature_importances_&#10;            feature_names = self.preprocessor.get_feature_names_out()&#10;            &#10;            # 选择前10个重要特征&#10;            indices = np.argsort(importances)[::-1][:10]&#10;            plt.bar(range(10), importances[indices])&#10;            plt.title('特征重要性 (Top 10)')&#10;            plt.xticks(range(10), [feature_names[i] for i in indices], rotation=45)&#10;        else:&#10;            plt.text(0.5, 0.5, '该模型无特征重要性', ha='center', va='center', transform=plt.gca().transAxes)&#10;        &#10;        plt.tight_layout()&#10;        plt.savefig('model_evaluation.png', dpi=300, bbox_inches='tight')&#10;        plt.show()&#10;    &#10;    def predict_test_data(self, test_df):&#10;        &quot;&quot;&quot;预测测试数据&quot;&quot;&quot;&#10;        print(&quot;对测试数据进行预测...&quot;)&#10;        &#10;        X_test_features, _, _ = self.prepare_features(test_df, is_train=False)&#10;        predictions = self.model.predict(X_test_features)&#10;        &#10;        # 创建结果DataFrame&#10;        result_df = test_df.copy()&#10;        result_df['predicted_rating'] = predictions&#10;        &#10;        return result_df, predictions&#10;&#10;def main():&#10;    &quot;&quot;&quot;主函数&quot;&quot;&quot;&#10;    predictor = MovieRatingPredictor()&#10;    &#10;    # 加载数据&#10;    train_df, test_df = predictor.load_and_preprocess_data(&#10;        'df_movies_cleaned.csv',&#10;        'input_data/df_movies_test.csv'&#10;    )&#10;    &#10;    # 准备训练数据&#10;    if 'rating' in train_df.columns:&#10;        X_train = train_df.drop('rating', axis=1)&#10;        y_train = train_df['rating']&#10;    else:&#10;        print(&quot;警告: 训练数据中未找到'rating'列，尝试使用所有特征...&quot;)&#10;        X_train = train_df&#10;        # 生成模拟的评分用于演示（实际使用时请删除）&#10;        y_train = np.random.normal(7.0, 1.5, len(train_df))&#10;        y_train = np.clip(y_train, 0, 10)&#10;    &#10;    # 训练模型&#10;    model_scores, trained_models = predictor.train_and_evaluate(X_train, y_train)&#10;    &#10;    # 创建验证集用于可视化&#10;    X_train_split, X_val_split, y_train_split, y_val_split = train_test_split(&#10;        X_train, y_train, test_size=0.2, random_state=42&#10;    )&#10;    &#10;    # 可视化结果&#10;    predictor.visualize_results(model_scores, X_val_split, y_val_split)&#10;    &#10;    # 预测测试数据&#10;    result_df, predictions = predictor.predict_test_data(test_df)&#10;    &#10;    # 保存结果&#10;    output_df = pd.DataFrame({&#10;        'id': test_df['id'] if 'id' in test_df.columns else range(len(test_df)),&#10;        'predicted_rating': predictions&#10;    })&#10;    &#10;    output_df.to_csv('output_result/predicted_ratings.csv', index=False)&#10;    &#10;    print(f&quot;预测完成！结果已保存到 output_result/predicted_ratings.csv&quot;)&#10;    print(f&quot;预测评分范围: {predictions.min():.2f} - {predictions.max():.2f}&quot;)&#10;    print(f&quot;预测评分均值: {predictions.mean():.2f}&quot;)&#10;    &#10;    # 显示模型性能总结&#10;    print(&quot;\n=== 模型性能总结 ===&quot;)&#10;    for model_name, scores in model_scores.items():&#10;        print(f&quot;{model_name}:&quot;)&#10;        print(f&quot;  RMSE: {scores['RMSE']:.4f}&quot;)&#10;        print(f&quot;  R²:   {scores['R2']:.4f}&quot;)&#10;        print(f&quot;  MAE:  {scores['MAE']:.4f}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>